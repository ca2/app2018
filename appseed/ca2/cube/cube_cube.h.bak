#pragma once


namespace cube
{


   class CLASS_DECL_ca2 cube :
      virtual public ::cube8::application,
      virtual public ::gen::system,
      virtual public debug_reporter
   {
   public:



      mutex                            m_mutexDelete;
      ::ca::application_ptra           m_appptra;
      class ::ca2::file::system        m_file;
      ::ca::dir::system_sp             m_spdir;
      class ::ca2::stra                m_stra;
      class ::ca2::url                 m_url;
      class ::ca2::html                m_html;
      class ::ca2::xml                 m_xml;
      class ::ca2::service             m_service;
      class ::ca2::install             m_install;
      ::ca::osi_sp                     m_sposi;
      class ::ca2::process             m_process;
      class ::ca2::datetime *          m_pdatetime;
      class ::ca2::net                 m_net;

      class ::ca4::compress            m_compress;
      class ::ca4::patch               m_patch;
      class ::ca4::crypt               m_crypt;
      class ::ca4::http::system        m_http;
      class ::ca4::email               m_email;
      class ::ca4::file                m_file4;
      class ::copydesk *               m_pcopydesk;
      ::ca4::port_forward_sp           m_spportforward;
      ::string_to_string_map           m_mapAppLibrary;


      class ::fontopus::user_set       m_userset;


      class ::ca2::log *               m_plog;
      class factory *                  m_pfactory;
      class ::ca::history *            m_phistory;
      class ::ca::window_draw *        m_ptwf;
      sp(::ca2::filehandler::handler)  m_spfilehandler;


      fontopus::authentication_map     m_authmap;


      bergedge::bergedge::run_start_installer *  m_prunstartinstaller;


      bergedge::bergedge::map *          m_pbergedgemap;

      index                            m_iNewEdge;

      class machine_event_central *    m_pmachineeventcentral;

      // certain instantiators like npca2plugin and iexca2plugin rely
      // on the functionality of these variables cached information,
      // to avoid multiple initialization.
      bool                             m_bInitApplication;
      BOOL                             m_bInitApplicationResult;
      bool                             m_bProcessInitialize;
      bool                             m_bProcessInitializeResult;


      bool                             m_bLibCharGuess;

      ::user::str *                    m_puserstr;

     ::collection::map < string, string, ::collection::map < int, int, string, string >, ::collection::map < int, int, string, string > > m_mapEnumToName;
     ::collection::map < string, string, ::collection::map < string, string, int, int >, ::collection::map < string, string, int, int > > m_mapNameToEnum;


      system();
      virtual ~system();


      //virtual int main();
      virtual BOOL InitApplication();

      virtual bool process_initialize();

      virtual bool initialize();
      virtual bool initialize1();
      virtual bool initialize3();

      virtual bool initialize_instance();

      virtual bool bergedge_start();

      virtual bool finalize();
      virtual int exit_instance();

      virtual index get_new_bergedge(::ca::application_bias * pbiasCreation = NULL);

      virtual void register_bergedge_application(::ca::application * papp);
      virtual void unregister_bergedge_application(::ca::application * papp);

      using ::cube8::application::alloc;
      virtual ::ca::ca * alloc(::ca::application * papp, ::ca::type_info & info);

      virtual ::ca::ca * on_alloc(::ca::application * papp, ::ca::type_info & info);
      virtual ::ca::ca * clone();
      virtual ::ca::ca * clone(::ca::ca * pobj);
      template < typename T >
      inline T * cast_clone(T * pt)
      {
         return dynamic_cast < T * > (clone(dynamic_cast < ::ca::ca * > (pt)));
      }

      virtual void appa_load_string_table();
      virtual void appa_set_locale(const char * pszLocale, bool bUser);
      virtual void appa_set_style(const char * pszStyle, bool bUser);

      virtual bool assert_running_global(const char * pszAppName, const char * pszId = NULL);
      virtual bool assert_running_local(const char * pszAppName, const char * pszId = NULL);

      virtual bool initialize_log(const char * pszId);

      virtual int _001OnDebugReport(int i1, const char * psz1, int i2, const char * psz2, const char * psz3, va_list args);

      virtual int ________ca2_votagus_logging_Report(
                                                      int _ReportType,
                                                      const char * _Filename,
                                                      int _Linenumber,
                                                      const char * _ModuleName,
                                                      const char * _Format,
                                                      va_list list);

      virtual bool assert_failed_line(const char * lpszFileName, int iLine);

      virtual void on_allocation_error(::ca::application * papp, ::ca::type_info & info);

      // file & dir
      using cube8::application::matter_as_string;
      virtual string matter_as_string(::ca::application * papp, const char * pszMatter, const char * pszMatter2 = NULL);
      using cube8::application::dir_matter;
      virtual string dir_matter(::ca::application * papp, const char * pszMatter, const char * pszMatter2 = NULL);
      virtual bool is_inside_time_dir(const char * pszPath);
      virtual bool file_is_read_only(const char * pszPath);
      using cube8::application::file_as_string;
      virtual string file_as_string(::ca::application * papp, const char * pszPath);
      virtual string dir_path(const char * psz1, const char * psz2, const char * psz3 = NULL);
      virtual string dir_name(const char * psz);
      virtual bool dir_mk(const char * psz);
      virtual string file_title(const char * psz);
      virtual string file_name(const char * psz);

      virtual ::ca::window_draw        * _001GetTwf();

      class factory                    & factory();
      class ::ca2::log                 & log();

      ::ca::window_draw                * get_twf();

      ::ca::application_ptra           & appptra();
      ::ca2::datetime                  & datetime();

      ::ca2::file::system              & file();
      ::ca::dir::system                & dir();
      ::ca2::stra                      & stra();
      ::ca2::url                       & url();
      ::ca2::html                      & html();
      ::ca2::xml                       & xml();
      ::ca2::install                   & install();
      ::ca2::service                   & service();
      machine_event_central            & machine_event_central();
      ::ca::osi                        & osi();
      ::ca2::process                   & process();
      class ::ca2::net                 & net();

      ::ca::history                    & hist();

      class ::ca4::compress            & compress();
      class ::ca4::patch               & patch();
      class ::ca4::crypt               & crypt();
      class ::ca4::http::system        & http();
      class ::ca4::email               & email();
      class ::ca4::file                & file36();
      class ::copydesk                 & copydesk();

      ::fontopus::user_set             & userset();

      ::user::str                      & str();

      ::ca2::filehandler::handler      & filehandler();

      virtual void on_delete(::ca::ca * pca);


      virtual bool base_support();

      bool sync_load_url(string & str, const char * lpszUrl, ::fontopus::user * puser = NULL, ::http::cookies * pcookies = NULL);

      DECL_GEN_SIGNAL(on_application_signal);

      virtual void http_config_proxy(const char * pszUrl, ::sockets::http_tunnel * psocket);

      using ::cube8::application::process;
      bool set_history(::ca::history * phistory);


      unsigned long guess_code_page(const char * pszText);


      bergedge::bergedge *             get_bergedge(index iEdge, ::ca::application_bias * pbiasCreation = NULL);
      platform::document *             get_platform(index iEdge, ::ca::application_bias * pbiasCreation = NULL);
      nature::document *               get_nature(index iEdge, ::ca::application_bias * pbiasCreation = NULL);

      bergedge::bergedge *             query_bergedge(index iEdge);


      void on_request(::ca::create_context * pcreatecontext);

      ::ca::application * application_get(index iEdge, const char * pszId, bool bCreate = true, bool bSynch = true, ::ca::application_bias * pbiasCreate = NULL);

      void open_by_file_extension(index iEdge, const char * pszPathName);

      static void register_delete(::ca::ca * plistened, ::ca::ca * plistener);
      static void unregister_delete(::ca::ca * plistened, ::ca::ca * plistenerOld);

      virtual bool wait_twf(DWORD dwTimeOut = INFINITE);

      void set_enum_name(::ca::type_info etype, int i, const char * psz)
      {
         m_mapEnumToName[etype.raw_name()][i] = psz;
         m_mapNameToEnum[etype.raw_name()][psz] = i;
      }
      string get_enum_name(::ca::type_info info, int i)
      {
         return m_mapEnumToName[info.raw_name()].get(i, "");
      }

      template < class E , E edefault>
      void from_name(base_enum < E, edefault > & b, const char * psz, E iDefault = edefault)
      {
         b = enum_from_name(::ca::get_type_info < E > (), psz, iDefault);
      }

      template < class E , E edefault>
      string get_name(const base_enum < E, edefault > & b)
      {
         return get_enum_name(::ca::get_type_info < E > (), (int) (E) b);
      }


      int enum_from_name(::ca::type_info info, const char * psz, int iDefault = 0)
      {
         return m_mapNameToEnum[info.raw_name()].get(psz, iDefault);
      }
      int enum_from_name(const std_type_info & info, const char * psz, int iDefault = 0)
      {
         return m_mapNameToEnum[info.raw_name()].get(psz, iDefault);
      }

      template < class TYPE >
      void set_enum_name(::ca::type_info etype, TYPE e, const char * psz)
      {
         set_enum_name(etype, (int) e, psz);
      }
      template < class TYPE >
      string get_enum_name(::ca::type_info etype, TYPE e)
      {
         return get_enum_name(etype, (int) e);
      }

      template < class TYPE >
      void set_enum_name(const std_type_info & info, TYPE e, const char * psz)
      {
         set_enum_name(::ca::type_info(info), (int) e, psz);
      }
      template < class TYPE >
      string get_enum_name(const std_type_info & info, TYPE e)
      {
         return get_enum_name(::ca::type_info(info), (int) e);
      }

      template < class TYPE >
      void set_enum_name(TYPE e, const char * psz)
      {
         set_enum_name(::ca::get_type_info < TYPE > (), (int) e, psz);
      }
      template < class TYPE >
      string get_enum_name(TYPE e)
      {
         return get_enum_name(::ca::get_type_info < TYPE > (), (int) e);
      }

      virtual bool create_twf();

      virtual bool is_system();

      virtual void discard_to_factory(::ca::ca * pca);

      virtual bool verb();

      virtual ::ca::application * get_new_app(::ca::application * pappNewApplicationParent, const char * pszId);

      virtual bool find_applications();
      virtual bool map_application_library(const char * pszLibrary);


      virtual bool set_main_init_data(::ca::main_init_data * pdata);

   };


} // namespace cube8


