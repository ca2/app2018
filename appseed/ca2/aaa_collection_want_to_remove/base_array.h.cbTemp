#pragma once


#undef new


#include "radix/radix_object.h"
#include "exception/exception_0.h"



template<class TYPE, class ARG_TYPE = const TYPE&>
class base_array :
   virtual public ::radix::object
{
public:

   class iterator
   {
   public:


      index            m_i;
      base_array *     m_parray;

      iterator()
      {
         m_i = 0;
         m_parray = NULL;
      }

      iterator(index i, base_array * parray)
      {
         m_i = i;
         m_parray = parray;
      }

      iterator(const iterator & it)
      {
         operator = (it);
      }

      TYPE & operator * ()
      {
         return m_parray->element_at(m_i);
      }

      const TYPE & operator * () const
      {
         return m_parray->element_at(m_i);
      }

      iterator & operator = (const iterator & it)
      {
         if(this != &it)
         {
            m_i         = it.m_i;
            m_parray    = it.m_parray;
         }
         return *this;
      }

      bool operator == (const iterator & it)
      {
         if(this == &it)
            return true;
         if(m_parray != it.m_parray)
            return false;
         if(m_i >= m_parray->get_size() && it.m_i >= m_parray->get_size())
            return true;
         if(m_i <= 0 && it.m_i <= 0)
            return true;
         return m_i == it.m_i;
      }

      bool operator != (const iterator & it)
      {
         return !operator==(it);
      }

      iterator & operator ++()
      {
         m_i++;
         if(m_i >= m_parray->get_size())
            m_i = m_parray->get_size();
         return *this;
      }

      iterator & operator +(int i)
      {
         m_i += i;
         if(m_i >= m_parray->get_size())
            m_i = m_parray->get_size();
         return *this;
      }

      iterator & operator --()
      {
         m_i--;
         if(m_i < 0)
            m_i = 0;
         return *this;
      }

   };


   typedef const iterator const_iterator;


   base_array();
   base_array(const base_array <TYPE, ARG_TYPE> & a);
   base_array(::count n, const TYPE & t = TYPE());
   template < typename OTHER >
   base_array(OTHER * pothera, ::count n)
   {
      m_pData = NULL;
      m_nSize = m_nMaxSize = m_nGrowBy = 0;
      while(n > 0)
      {
         add(*pothera);
         pothera++;
         n--;
      }
   }
   base_array(TYPE * ptypea, ::count n)
   {
      m_pData = NULL;
      m_nSize = m_nMaxSize = m_nGrowBy = 0;
      while(n > 0)
      {
         add(*ptypea);
         ptypea++;
         n--;
      }
   }
   virtual ~base_array();

// Attributes
   ::count get_size() const;
   ::count get_count() const;
   ::count size() const;
   ::count count() const;
   bool is_empty(::count countMinimum = 1) const;
   bool has_elements(::count countMinimum = 1) const;
   index get_upper_bound() const;
   ::count set_size(::count nNewSize, ::count nGrowBy = -1);

   void free_extra();



   // Accessing elements
   const TYPE& get_at(index nIndex) const;
   TYPE& get_at(index nIndex);
   void set_at(index nIndex, ARG_TYPE newElement);
   const TYPE& element_at(index nIndex) const;
   TYPE& element_at(index nIndex);

   // Direct Access to the element data (may return NULL)
   const TYPE* get_data() const;
   TYPE* get_data();

   // Potentially growing the base_array
   void set_at_grow(index nIndex, ARG_TYPE newElement);
   virtual index add_new(::count count = 1);
   virtual index add(ARG_TYPE newElement);
   virtual ::count add(const base_array& src); // for disambiguation
   virtual ::count add_array(const base_array& src);
   void copy(const base_array& src);

   virtual index insert_new(::count count = 1);
   virtual index insert(ARG_TYPE newElement);

   // overloaded operator helpers
   const TYPE& operator[](index nIndex) const;
   TYPE& operator[](index nIndex);

   // Operations that move elements around
   void insert_at(index nIndex, ARG_TYPE newElement, ::count nCount = 1);
   void remove_at(index nIndex, ::count nCount = 1);
   iterator erase(iterator pos);
   iterator erase(iterator first, iterator last);
   void insert_at(index nStartIndex, base_array* pNewArray);
   void insert_array_at(index nStartIndex, base_array* pNewArray); // for disambiguation
   void remove_last();


   void increment_size(::count add_up = 1);

   iterator begin()
   {
      return iterator(0, this);
   }

   iterator end()
   {
      return iterator(get_size(), this);
   }

   TYPE & first_element();
   const TYPE & first_element() const;
   TYPE & front();
   const TYPE & front() const;
   TYPE & last_element();
   const TYPE & last_element() const;
   TYPE & back();
   const TYPE & back() const;
   ::count remove_all(bool bResize = false);
   void clear(::ca::ca::flag eflag);
   void clear();

   index find_first(ARG_TYPE t, index (* lpfnCompare)(ARG_TYPE, ARG_TYPE), index start = 0, index last = -1) const;
   index raw_find_first(TYPE * pt, index first = 0, index last = -1) const;

   template < class DERIVED >
   index find_first(DERIVED * pt, index first = 0, index last = -1)
   {
      return raw_find_first(dynamic_cast < TYPE * > (pt), first, last);
   }

   void swap(index i1, index i2);

   base_array <TYPE, ARG_TYPE> & operator = (const base_array <TYPE, ARG_TYPE> & a);

   TYPE pop();
   void push(ARG_TYPE t);
   void pop_back();
   void push_back(ARG_TYPE t);


// Implementation
protected:
   TYPE *   m_pData;   // the actual base_array of data
   ::count    m_nSize;     // # of elements (upperBound - 1)
   ::count    m_nMaxSize;  // max allocated
   ::count    m_nGrowBy;   // grow amount

public:
//   void Serialize(CArchive&);
#ifdef _DEBUG
   void dump(dump_context&) const;
   void assert_valid() const;
#endif
};

template<class TYPE, class ARG_TYPE>
base_array<TYPE, ARG_TYPE>::base_array(const base_array<TYPE, ARG_TYPE> & a)
{
   m_pData = NULL;
   m_nSize = m_nMaxSize = m_nGrowBy = 0;
   operator =(a);
}

template<class TYPE, class ARG_TYPE>
base_array<TYPE, ARG_TYPE>::base_array(::count n, const TYPE & t)
{
   m_pData = NULL;
   m_nSize = m_nMaxSize = m_nGrowBy = 0;
   while(n > 0)
   {
      add((ARG_TYPE) t);
   }
}

template<class TYPE, class ARG_TYPE>
void base_array<TYPE, ARG_TYPE>::
increment_size(::count iAddUp)
{
    set_size(get_size() + iAddUp);
}

template<class TYPE, class ARG_TYPE>
TYPE & base_array<TYPE, ARG_TYPE>::
last_element()
{
    ASSERT(get_size() > 0);
    return this->element_at(get_size() - 1);
}

template<class TYPE, class ARG_TYPE>
const TYPE & base_array<TYPE, ARG_TYPE>::
last_element() const
{
    ASSERT(get_size() > 0);
    return this->element_at(get_size() - 1);
}

template<class TYPE, class ARG_TYPE>
TYPE & base_array<TYPE, ARG_TYPE>::
back()
{
    ASSERT(get_size() > 0);
    return this->element_at(get_size() - 1);
}

template<class TYPE, class ARG_TYPE>
const TYPE & base_array<TYPE, ARG_TYPE>::
back() const
{
    ASSERT(get_size() > 0);
    return this->element_at(get_size() - 1);
}

template<class TYPE, class ARG_TYPE>
TYPE & base_array<TYPE, ARG_TYPE>::
first_element()
{
    ASSERT(get_size() > 0);
    return this->element_at(0);
}

template<class TYPE, class ARG_TYPE>
const TYPE & base_array<TYPE, ARG_TYPE>::
first_element() const
{
    ASSERT(get_size() > 0);
    return get_at(0);
}

template<class TYPE, class ARG_TYPE>
TYPE & base_array<TYPE, ARG_TYPE>::
front()
{
    ASSERT(get_size() > 0);
    return this->element_at(0);
}

template<class TYPE, class ARG_TYPE>
const TYPE & base_array<TYPE, ARG_TYPE>::
front() const
{
    ASSERT(get_size() > 0);
    return get_at(0);
}

template <class TYPE, class ARG_TYPE>
::count base_array<TYPE, ARG_TYPE>::
remove_all(bool bResize)
{
   ::count countOld = get_count();
   if(bResize)
   {
      set_size(0, -1);
   }
   else
   {
      remove_at(0, m_nSize);
   }
   return countOld;
}

template <class TYPE, class ARG_TYPE>
inline void base_array<TYPE, ARG_TYPE>::
clear(::ca::ca::flag flag)
{
   ::ca::ca::clear(flag);
}


template <class TYPE, class ARG_TYPE>
void base_array<TYPE, ARG_TYPE>::
clear()
{
   remove_all();
}

template <class TYPE, class ARG_TYPE>
void base_array<TYPE, ARG_TYPE>::swap(index i1, index i2)
{
    TYPE t;
    t = this->element_at(i1);
    this->element_at(i1) = this->element_at(i2);
    this->element_at(i2) = t;
}

template <class TYPE, class ARG_TYPE>
index base_array<TYPE, ARG_TYPE>::raw_find_first(TYPE *pt, index find, index last) const
{
   if(find < 0)
      find += get_count();
   if(last < 0)
      last += get_count();
   for(; find <= last; find++)
   {
      if(&this->element_at(find) == pt)
         return find;
   }
   return -1;
}
template <class TYPE, class ARG_TYPE>
index base_array<TYPE, ARG_TYPE>::find_first(ARG_TYPE t, index ( * lpfnCompare )(ARG_TYPE, ARG_TYPE), index find, index last) const
{
   if(find < 0)
      find += get_count();
   if(last < 0)
      last += get_count();
   for(; find <= last; find++)
   {
      if(lpfnCompare((ARG_TYPE)this->element_at(find), (ARG_TYPE)t) == 0)
         return find;
   }
   return -1;
}



template <class TYPE, class ARG_TYPE>
base_array <TYPE, ARG_TYPE> &
base_array<TYPE, ARG_TYPE>::
operator = (const base_array <TYPE, ARG_TYPE> & a)
{
   if(&a == this)
      return *this;
   copy(a);
   return * this;
}

template <class TYPE, class ARG_TYPE>
inline TYPE base_array <TYPE, ARG_TYPE>::pop()
{
   ASSERT(get_size() > 0);
   TYPE t = last_element();
   remove_at(get_upper_bound());
   return t;
}

template <class TYPE, class ARG_TYPE>
inline void base_array <TYPE, ARG_TYPE>::
push(ARG_TYPE t)
{
   add(t);
}

template <class TYPE, class ARG_TYPE>
inline void base_array <TYPE, ARG_TYPE>::pop_back()
{
   ASSERT(get_size() > 0);
   remove_at(get_upper_bound());
}

template <class TYPE, class ARG_TYPE>
inline void base_array <TYPE, ARG_TYPE>::
push_back(ARG_TYPE t)
{
   add(t);
}

#define new DEBUG_NEW


typedef base_array < sync_object_base * > sync_object_ptra;
